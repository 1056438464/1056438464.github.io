<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<title>Spring框架——AOP | shang wj</title>


<link rel="stylesheet" href="/styles/main.css">


    <meta name="generator" content="Hexo 7.3.0"></head>
    <body>
        <div class="container">
            <header>
<div class="main">
<div class="title">
    <a href="#" class="logo">shang wj</a>
</div>
<div class="site-nav">
    <ul id="menu" class="menu">
    
        <li class="menu-item text-underline">
            <a href="/">Home</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/archives">Archives</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/about/">About</a>
        </li>
            
    </ul>
</div>
</div>
</header>
            <main class="main">
                <section class="posts clearfix">
<div class="post-wrapper">
    <article class="post article-entry">
    <div class="post-title">
        Spring框架——AOP
    </div>
    <p class="sub">Aug 26 2018</p>
    <div class="post-content">
        <h3 id="1-什么是AOP编程"><a href="#1-什么是AOP编程" class="headerlink" title="1.什么是AOP编程"></a>1.什么是AOP编程</h3><p>主要是分离业务代码与关注点代码<br>aop( aspect oriented programming ) 面向切面(方面)编程,是对所有对象或者是一类对象编程,核心是( 在不增加代码的基础上， 还增加新功能 )<br>也可以理解是面向<strong>同一种类型</strong>bean进行编程，或者是面向<strong>N多对象</strong>进行编程。</p>
<h4 id="1-1-概念："><a href="#1-1-概念：" class="headerlink" title="1.1 概念："></a>1.1 概念：</h4><pre><code>Aop编程：
    关注点代码与业务代码分离！(jdk/cglib代理)
关注点：
    重复执行的代码, 也叫关注点代码!
切面：
    关注点代码形成的类，就叫做切面（事务，权限控制, 日志）
切入点表达式
    拦截方法，给方法所在的类，生成代理对象！
    Spring在初始化容器的时候，会根据切入点表达式的规则，会符合拦截规则的方法所在的类生成代理对象！
</code></pre>
<h3 id="2-实现AOP编程——代理"><a href="#2-实现AOP编程——代理" class="headerlink" title="2.实现AOP编程——代理"></a>2.实现AOP编程——代理</h3><p><strong>概念：</strong><br>Proxy, 表示代理！ 提供了对目标对象另外的访问方式，即通过代理访问目标对象</p>
<p><strong>Java中代理：</strong></p>
<ol>
<li>静态代理</li>
<li>动态代理–Jdk 代理</li>
<li>Cglib 代理</li>
</ol>
<h4 id="2-1-静态代理"><a href="#2-1-静态代理" class="headerlink" title="2.1 静态代理"></a>2.1 静态代理</h4><p><strong>特点：</strong></p>
<ol>
<li><strong>目标对象</strong>必须要实现接口</li>
<li>代理对象，要<strong>实现与目标对象一样的接口</strong></li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>代理对象，需要依赖目标对象的接口！如果接口功能变化，目标对象变化，会引入代理对象的变化!</li>
<li>对每一个目标对象，都要分别写一个代理类，麻烦！(代理工厂)</li>
</ol>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IUserDao接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">find</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标对象UserDao</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;模拟： 保存用户！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;查询&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *代理对象UserDaoProxy</span></span><br><span class="line"><span class="comment"> * 静态代理</span></span><br><span class="line"><span class="comment">          特点：</span></span><br><span class="line"><span class="comment">	1. 目标对象必须要实现接口</span></span><br><span class="line"><span class="comment">	2. 代理对象，要实现与目标对象一样的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 代理对象，需要维护一个目标对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">IUserDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;代理操作： 开启事务...&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		target.save();   <span class="comment">// 执行目标对象的方法</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;代理操作：提交事务...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">()</span> &#123;</span><br><span class="line">		target.find();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 代理对象</span></span><br><span class="line">		<span class="type">IUserDao</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>();</span><br><span class="line">		<span class="comment">// 执行代理方法</span></span><br><span class="line">		proxy.save();</span><br><span class="line">		 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-2-动态代理"><a href="#2-2-动态代理" class="headerlink" title="2.2 动态代理"></a>2.2 动态代理</h4><p><strong>动态代理：</strong></p>
<ol>
<li>通常说的动态代理，就是指jdk代理!因为是通过jdk的api在运行时期，动态的生成代理对象的！</li>
<li><strong>目标对象一定要实现接口, 代理对象不用实现接口!</strong></li>
</ol>
<p><strong>JDK 生成代理对象的Api</strong><br><img src="https://www.swj233.top/usr/uploads/2018/08/2106354247.png"><br><strong>参数loader :</strong><br>当前目标对象使用的类加载器！<br><strong>参数interfaces :  **<br>当前目标对象实现的接口<br><strong>参数 h: **<br>    接口类型，事件处理器.<br>    当执行目标对象方法的时候，会触发事件； 把当前执行的方法(method对象)，传入事件处理器方法参数中,  这样就可以根据业务逻辑，判断是否执行目标对象方法或扩展功能！<br>InvocationHandler对象会直接调用自己的invoke方法，invoke方法将</strong>目标对象传入</strong>调用目标对象方法<code>（method.invoke(target, args)）</code>，而在本例中UserDao就是<strong>目标对象</strong>，而UserDao.save是目标方法method<br><img src="https://www.swj233.top/usr/uploads/2018/08/1414442860.png"></p>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// IUserDao接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">find</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标对象UserDao</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span>&#123;</span><br><span class="line"><span class="comment">//method</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;模拟： 保存用户！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;查询&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理对象</span></span><br><span class="line"><span class="comment"> * 动态代理：</span></span><br><span class="line"><span class="comment"> *    代理工厂，给多个目标对象生成代理对象！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> AdminTH</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接收一个目标对象</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回对目标对象(target)代理后的对象(proxy)</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> Proxy.newProxyInstance(</span><br><span class="line">				target.getClass().getClassLoader(),  <span class="comment">// 目标对象使用的类加载器</span></span><br><span class="line">				target.getClass().getInterfaces(),   <span class="comment">// 目标对象实现的所有接口</span></span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;			<span class="comment">// 执行代理对象方法时候触发</span></span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">							<span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">						</span><br><span class="line">						<span class="comment">// 获取当前执行的方法的方法名</span></span><br><span class="line">						<span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">						<span class="comment">// 方法返回值</span></span><br><span class="line">						<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">						</span><br><span class="line">						<span class="comment">// 判断</span></span><br><span class="line">						<span class="keyword">if</span> (<span class="string">&quot;find&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">							<span class="comment">// 直接调用目标对象方法</span></span><br><span class="line">							result = method.invoke(target, args);</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							System.out.println(<span class="string">&quot;开启事务...&quot;</span>);</span><br><span class="line">							<span class="comment">// 执行目标对象方法</span></span><br><span class="line">							result = method.invoke(target, args);</span><br><span class="line">							System.out.println(<span class="string">&quot;提交事务...&quot;</span>);</span><br><span class="line">							</span><br><span class="line">						&#125;</span><br><span class="line">						</span><br><span class="line">						</span><br><span class="line">						<span class="keyword">return</span> result;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		);</span><br><span class="line">		<span class="keyword">return</span> proxy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 创建目标对象</span></span><br><span class="line">		<span class="type">IUserDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;目标对象：&quot;</span> + target.getClass());  <span class="comment">// class cn.itcast.b_dynamic.UserDao</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 代理对象</span></span><br><span class="line">		<span class="type">IUserDao</span> <span class="variable">proxy</span> <span class="operator">=</span> (IUserDao) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();</span><br><span class="line">		System.out.println(<span class="string">&quot;代理对象： &quot;</span> + proxy.getClass());  <span class="comment">//  class $Proxy0</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 执行代理对象的方法</span></span><br><span class="line">		proxy.save();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-CGLIB-代理"><a href="#2-3-CGLIB-代理" class="headerlink" title="2.3 CGLIB 代理"></a>2.3 CGLIB 代理</h4><p><strong>概念：</strong><br>也叫”子类代理”<br>当目标对象没有实现接口，就不能使用jdk提供的代理，可以以子类的方式实现！<br>在运行时期动态在内存中构建一个子类对象的方法，从而对目标对象扩展，这种就是cglib代理！<br>Spring也支持cglib代理，核心包中已经包含此功能！</p>
<ul>
<li>JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。如果想代理没有实现接口的类，就可以使用CGLIB实现。</li>
<li>CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。 </li>
<li>CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉</li>
</ul>
<p><strong>特点：</strong></p>
<ol>
<li>目标对象可以不实现接口</li>
<li>目标类不能为final， 如果为final报错</li>
<li>方法如果为final&#x2F;static, 不会被代理拦截！ 会直接执行目标对象方法 ！</li>
</ol>
<p><strong>核心代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cglib代理：</span></span><br><span class="line"><span class="comment"> *    代理工厂，给多个目标对象生成代理对象！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> AdminTH</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接收一个目标对象</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回目标对象代理后的子类对象</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 对target生成子类对象</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 字节码生成工具类</span></span><br><span class="line">		<span class="type">Enhancer</span> <span class="variable">en</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">		<span class="comment">// 设置父类</span></span><br><span class="line">		en.setSuperclass(target.getClass());</span><br><span class="line">		<span class="comment">// 设置回调函数</span></span><br><span class="line">		en.setCallback(<span class="built_in">this</span>);</span><br><span class="line">		<span class="comment">// 创建子类对象</span></span><br><span class="line">		<span class="keyword">return</span> en.create();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 事件处理器，执行目标方法时候触发</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args,</span></span><br><span class="line"><span class="params">			MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;开启事务...&quot;</span>);</span><br><span class="line">		<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">		System.out.println(<span class="string">&quot;提交事务...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用对象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 创建目标对象</span></span><br><span class="line">		<span class="type">UserDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;目标对象：&quot;</span> + target.getClass());  <span class="comment">// class cn.itcast.c_cglib.UserDao</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 代理对象</span></span><br><span class="line">		<span class="type">UserDao</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserDao) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();</span><br><span class="line">		System.out.println(<span class="string">&quot;代理对象： &quot;</span> + proxy.getClass());  <span class="comment">//  class cn.itcast.c_cglib.UserDao$$EnhancerByCGLIB$$6ecf51fe</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 执行代理对象的方法</span></span><br><span class="line">		proxy.save();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    </div>
    </article>
</div>

    <div class="_toc">
        <strong class="toc-title">
        Contents
        </strong>
        <div class="toc-content">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFAOP%E7%BC%96%E7%A8%8B"><span class="toc-text">1.什么是AOP编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">1.1 概念：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0AOP%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86"><span class="toc-text">2.实现AOP编程——代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">2.1 静态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">2.2 动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-CGLIB-%E4%BB%A3%E7%90%86"><span class="toc-text">2.3 CGLIB 代理</span></a></li></ol></li></ol>
        </div>
    </div>

</section>


    <nav class="post-nav">
        
            <div class="page-tags">
                
            </div>
        
    </nav>



    <nav class="paginator clearfix">
        
            <a class="prev" href="/2018/08/26/225/">
                <i class="iconfont icon-left"></i>
                <span class="prev-text">实现AOP——注解和XML配置</span>
            </a>
        
        
            <a class="next" href="/2018/08/25/220/">
                
                <span class="prev-text">Spring框架——IOC</span>
                <i class="iconfont icon-right"></i>
            </a>
        
    </nav>


            </main>
            <div class="copyright">
  <div class="text">Powered By
    <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/zjx137/hexo-theme-Tsu">Tsu</a> &copy 2019
  </div>
</div>

        </div>
    <div class="back-to-top" id="back-to-top">
            <i class="iconfont icon-up"></i>
    </div>
        
    </body>
    
<script src="/js/jquery-3.3.1.min.js"></script>

    
<script src="/js/back-to-top.js"></script>

    
<script src="/js/scroll.js"></script>

    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

</html>
