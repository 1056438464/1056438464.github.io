<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<title>golang 并发控制context实现原理剖析 | shang wj</title>


<link rel="stylesheet" href="/styles/main.css">


    <meta name="generator" content="Hexo 7.3.0"></head>
    <body>
        <div class="container">
            <header>
<div class="main">
<div class="title">
    <a href="#" class="logo">shang wj</a>
</div>
<div class="site-nav">
    <ul id="menu" class="menu">
    
        <li class="menu-item text-underline">
            <a href="/">Home</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/archives">Archives</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/about/">About</a>
        </li>
            
    </ul>
</div>
</div>
</header>
            <main class="main">
                <section class="posts clearfix">
<div class="post-wrapper">
    <article class="post article-entry">
    <div class="post-title">
        golang 并发控制context实现原理剖析
    </div>
    <p class="sub">Jul 14 2020</p>
    <div class="post-content">
        <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>Golang context是Golang应用开发常用的并发控制技术，它与WaitGroup最大的不同点是context对于派生goroutine有更强的控制力，它可以控制多级的goroutine。</p>
<p>context翻译成中文是”上下文”，即它可以控制一组呈树状结构的goroutine，每个goroutine拥有相同的上下文。</p>
<p>典型的使用场景如下图所示：</p>
<p><img src="/../images/context1.png" alt="avatar"></p>
<p>上图中由于goroutine派生出子goroutine，而子goroutine又继续派生新的goroutine，这种情况下使用WaitGroup就不太容易，因为子goroutine个数不容易确定。而使用context就可以很容易实现。</p>
<h2 id="2-Context实现原理"><a href="#2-Context实现原理" class="headerlink" title="2. Context实现原理"></a>2. Context实现原理</h2><p>context实际上只定义了接口，凡是实现该接口的类都可称为是一种context，官方包中实现了几个常用的context，分别可用于不同的场景。</p>
<h3 id="2-1-接口定义"><a href="#2-1-接口定义" class="headerlink" title="2.1 接口定义"></a>2.1 接口定义</h3><p>源码包中src&#x2F;context&#x2F;context.go:Context 定义了该接口：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基础的context接口只定义了4个方法，下面分别简要说明一下：</p>
<h4 id="2-1-1-Deadline"><a href="#2-1-1-Deadline" class="headerlink" title="2.1.1 Deadline()"></a>2.1.1 Deadline()</h4><p>该方法返回一个deadline和标识是否已设置deadline的bool值，如果没有设置deadline，则ok &#x3D;&#x3D; false，此时deadline为一个初始值的time.Time值</p>
<h4 id="2-1-2-Done"><a href="#2-1-2-Done" class="headerlink" title="2.1.2 Done()"></a>2.1.2 Done()</h4><p>该方法返回一个channel，需要在select-case语句中使用，如”case &lt;-context.Done():”。</p>
<p>当context关闭后，Done()返回一个被关闭的管道，关闭的管理仍然是可读的，据此goroutine可以收到关闭请求； 当context还未关闭时，Done()返回nil。</p>
<h4 id="2-1-3-Err"><a href="#2-1-3-Err" class="headerlink" title="2.1.3 Err()"></a>2.1.3 Err()</h4><p>该方法描述context关闭的原因。关闭原因由context实现控制，不需要用户设置。比如Deadline context，关闭原因可能是因为deadline，也可能提前被主动关闭，那么关闭原因就会不同:</p>
<p>因deadline关闭：“context deadline exceeded”；<br>因主动关闭： “context canceled”。<br>当context关闭后，Err()返回context的关闭原因； 当context还未关闭时，Err()返回nil；</p>
<h4 id="2-1-3-Value"><a href="#2-1-3-Value" class="headerlink" title="2.1.3 Value()"></a>2.1.3 Value()</h4><p>有一种context，它不是用于控制呈树状分布的goroutine，而是用于在树状分布的goroutine间传递信息。</p>
<p>Value()方法就是用于此种类型的context，该方法根据key值查询map中的value。具体使用后面示例说明。</p>
<h3 id="2-2-空context"><a href="#2-2-空context" class="headerlink" title="2.2 空context"></a>2.2 空context</h3><p>context包中定义了一个空的context， 名为emptyCtx，用于context的根节点，空的context只是简单的实现了Context，本身不包含任何值，仅用于其他context的父节点。</p>
<p>emptyCtx类型定义如下代码所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>context包中定义了一个公用的emptCtx全局变量，名为background，可以使用context.Background()获取它，实现代码如下所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>context包提供了4个方法创建不同类型的context，使用这四个方法时如果没有父context，都需要传入backgroud，即backgroud作为其父节点：</p>
<ul>
<li>WithCancel()</li>
<li>WithDeadline()</li>
<li>WithTimeout()</li>
<li>WithValue()</li>
</ul>
<p>context包中实现Context接口的struct，除了emptyCtx外，还有cancelCtx、timerCtx和valueCtx三种，正是基于这三种context实例，实现了上述4种类型的context。</p>
<p>context包中各context类型之间的关系，如下图所示：</p>
<p><img src="/../images/context2.webp" alt="avatar"></p>
<p>struct cancelCtx、valueCtx、valueCtx都继承于Context，下面分别介绍这三个struct。</p>
<h3 id="2-3-cancelCtx"><a href="#2-3-cancelCtx" class="headerlink" title="2.3 cancelCtx"></a>2.3 cancelCtx</h3><p>源码包中src&#x2F;context&#x2F;context.go:cancelCtx 定义了该类型context：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">	done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">	children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">	err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>children中记录了由此context派生的所有child，此context被cancle时会把其中的所有child都cancle掉。</p>
<p>cancelCtx与deadline和value无关，所以只需要实现Done()和Err()接口外露接口即可。</p>
<h4 id="2-3-1-Done-接口实现"><a href="#2-3-1-Done-接口实现" class="headerlink" title="2.3.1 Done()接口实现"></a>2.3.1 Done()接口实现</h4><p>按照Context定义，Done()接口只需要返回一个channel即可，对于cancelCtx来说只需要返回成员变量done即可。</p>
<p>这里直接看下源码，非常简单：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	d := c.done</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于cancelCtx没有指定初始化函数，所以cancelCtx.done可能还未分配，所以需要考虑初始化。<br>cancelCtx.done会在context被cancel时关闭，所以cancelCtx.done的值一般经历如三个阶段： nil –&gt; chan struct{} –&gt; closed chan。</p>
<h4 id="2-3-2-Err-接口实现"><a href="#2-3-2-Err-接口实现" class="headerlink" title="2.3.2 Err()接口实现"></a>2.3.2 Err()接口实现</h4><p>按照Context定义，Err()只需要返回一个error告知context被关闭的原因。对于cancelCtx来说只需要返回成员变量err即可。</p>
<p>还是直接看下源码：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	err := c.err</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cancelCtx.err默认是nil，在context被cancel时指定一个error变量： <code>var Canceled = errors.New(&quot;context canceled&quot;)</code>。</p>
<h4 id="2-3-3-cancel-接口实现"><a href="#2-3-3-cancel-接口实现" class="headerlink" title="2.3.3 cancel()接口实现"></a>2.3.3 cancel()接口实现</h4><p>cancel()内部方法是理解cancelCtx的最关键的方法，其作用是关闭自己和其后代，其后代存储在cancelCtx.children的map中，其中key值即后代对象，value值并没有意义，这里使用map只是为了方便查询而已。</p>
<p>cancel方法实现伪代码如下所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">	</span><br><span class="line">    c.err = err	                      <span class="comment">//设置一个error，说明关闭原因</span></span><br><span class="line">    <span class="built_in">close</span>(c.done)                     <span class="comment">//将channel关闭，以此通知派生的context</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;   <span class="comment">//遍历所有children，逐个调用cancel方法</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;            <span class="comment">//正常情况下，需要将自己从parent删除</span></span><br><span class="line">        removeChild(c.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，WithCancel()返回的第二个用于cancel context的方法正是此cancel()。</p>
<h4 id="2-3-4-WithCancel-方法实现"><a href="#2-3-4-WithCancel-方法实现" class="headerlink" title="2.3.4 WithCancel()方法实现"></a>2.3.4 WithCancel()方法实现</h4><p>WithCancel()方法作了三件事：</p>
<ul>
<li>初始化一个cancelCtx实例</li>
<li>将cancelCtx实例添加到其父节点的children中(如果父节点也可以被cancel的话)<br>*返回cancelCtx实例和cancel()方法</li>
</ul>
<p>其实现源码如下所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">	c := newCancelCtx(parent)</span><br><span class="line">	propagateCancel(parent, &amp;c)   <span class="comment">//将自身添加到父节点</span></span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将自身添加到父节点的过程有必要简单说明一下：</p>
<ol>
<li>如果父节点也支持cancel，也就是说其父节点肯定有children成员，那么把新context添加到children里即可；</li>
<li>如果父节点不支持cancel，就继续向上查询，直到找到一个支持cancel的节点，把新context添加到children里；</li>
<li>如果所有的父节点均不支持cancel，则启动一个协程等待父节点结束，然后再把当前context结束。</li>
</ol>
<h4 id="2-3-5-典型使用案例"><a href="#2-3-5-典型使用案例" class="headerlink" title="2.3.5 典型使用案例"></a>2.3.5 典型使用案例</h4><p>一个典型的使用cancel context的例子如下所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandelRequest</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> WriteRedis(ctx)</span><br><span class="line">    <span class="keyword">go</span> WriteDatabase(ctx)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;HandelRequest Done.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;HandelRequest running&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteRedis</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteRedis Done.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteRedis running&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteDatabase</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteDatabase Done.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteDatabase running&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">go</span> HandelRequest(ctx)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;It&#x27;s time to stop all sub goroutines!&quot;</span>)</span><br><span class="line">    cancel()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Just for test whether sub goroutines exit or not</span></span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中协程HandelRequest()用于处理某个请求，其又会创建两个协程：WriteRedis()、WriteDatabase()，main协程创建创建context，并把context在各子协程间传递，main协程在适当的时机可以cancel掉所有子协程。</p>
<p>程序输出如下所示：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HandelRequest running</span><br><span class="line">WriteDatabase running</span><br><span class="line">WriteRedis running</span><br><span class="line">HandelRequest running</span><br><span class="line">WriteDatabase running</span><br><span class="line">WriteRedis running</span><br><span class="line">HandelRequest running</span><br><span class="line">WriteDatabase running</span><br><span class="line">WriteRedis running</span><br><span class="line">It&#x27;s <span class="built_in">time</span> to stop all sub goroutines!</span><br><span class="line">WriteDatabase Done.</span><br><span class="line">HandelRequest Done.</span><br><span class="line">WriteRedis Done.</span><br></pre></td></tr></table></figure>

<h3 id="2-4-timerCtx"><a href="#2-4-timerCtx" class="headerlink" title="2.4 timerCtx"></a>2.4 timerCtx</h3><p>源码包中src&#x2F;context&#x2F;context.go:timerCtx 定义了该类型context：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	cancelCtx</span><br><span class="line">	timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">	deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>timerCtx在cancelCtx基础上增加了deadline用于标示自动cancel的最终时间，而timer就是一个触发自动cancel的定时器。</p>
<p>由此，衍生出WithDeadline()和WithTimeout()。实现上这两种类型实现原理一样，只不过使用语境不一样：</p>
<p>deadline: 指定最后期限，比如context将2018.10.20 00:00:00之时自动结束<br>timeout: 指定最长存活时间，比如context将在30s后结束。<br>对于接口来说，timerCtx在cancelCtx基础上还需要实现Deadline()和cancel()方法，其中cancel()方法是重写的。</p>
<h4 id="2-4-1-Deadline-接口实现"><a href="#2-4-1-Deadline-接口实现" class="headerlink" title="2.4.1 Deadline()接口实现"></a>2.4.1 Deadline()接口实现</h4><p>Deadline()方法仅仅是返回timerCtx.deadline而矣。而timerCtx.deadline是WithDeadline()或WithTimeout()方法设置的。</p>
<h4 id="2-4-2-cancel-接口实现"><a href="#2-4-2-cancel-接口实现" class="headerlink" title="2.4.2 cancel()接口实现"></a>2.4.2 cancel()接口实现</h4><p>cancel()方法基本继承cancelCtx，只需要额外把timer关闭。</p>
<p>timerCtx被关闭后，timerCtx.cancelCtx.err将会存储关闭原因：</p>
<p>如果deadline到来之前手动关闭，则关闭原因与cancelCtx显示一致；<br>如果deadline到来时自动关闭，则原因为：<code>&quot;context deadline exceeded&quot;</code></p>
<h4 id="2-4-3-WithDeadline-方法实现"><a href="#2-4-3-WithDeadline-方法实现" class="headerlink" title="2.4.3 WithDeadline()方法实现"></a>2.4.3 WithDeadline()方法实现</h4><p>WithDeadline()方法实现步骤如下：</p>
<ul>
<li>初始化一个timerCtx实例</li>
<li>将timerCtx实例添加到其父节点的children中(如果父节点也可以被cancel的话)</li>
<li>启动定时器，定时器到期后会自动cancel本context</li>
<li>返回timerCtx实例和cancel()方法</li>
</ul>
<p>也就是说，timerCtx类型的context不仅支持手动cancel，也会在定时器到来后自动cancel。</p>
<h4 id="2-4-4-WithTimeout-方法实现"><a href="#2-4-4-WithTimeout-方法实现" class="headerlink" title="2.4.4 WithTimeout()方法实现"></a>2.4.4 WithTimeout()方法实现</h4><p>WithTimeout()实际调用了WithDeadline，二者实现原理一致。</p>
<p>看代码会非常清晰：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">	<span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-5-典型使用案例"><a href="#2-4-5-典型使用案例" class="headerlink" title="2.4.5 典型使用案例"></a>2.4.5 典型使用案例</h4><p>下面例子中使用WithTimeout()获得一个context并在其了协程中传递：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandelRequest</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> WriteRedis(ctx)</span><br><span class="line">    <span class="keyword">go</span> WriteDatabase(ctx)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;HandelRequest Done.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;HandelRequest running&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteRedis</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteRedis Done.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteRedis running&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteDatabase</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteDatabase Done.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteDatabase running&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, _ := context.WithTimeout(context.Background(), <span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="keyword">go</span> HandelRequest(ctx)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主协程中创建一个10s超时的context，并将其传递给子协程，10s自动关闭context。程序输出如下：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HandelRequest running</span><br><span class="line">WriteRedis running</span><br><span class="line">WriteDatabase running</span><br><span class="line">HandelRequest running</span><br><span class="line">WriteRedis running</span><br><span class="line">WriteDatabase running</span><br><span class="line">HandelRequest running</span><br><span class="line">WriteRedis running</span><br><span class="line">WriteDatabase running</span><br><span class="line">HandelRequest Done.</span><br><span class="line">WriteDatabase Done.</span><br><span class="line">WriteRedis Done.</span><br></pre></td></tr></table></figure>

<h3 id="2-5-valueCtx"><a href="#2-5-valueCtx" class="headerlink" title="2.5 valueCtx"></a>2.5 valueCtx</h3><p>源码包中src&#x2F;context&#x2F;context.go:valueCtx 定义了该类型context：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>valueCtx只是在Context基础上增加了一个key-value对，用于在各级协程间传递一些数据。</p>
<p>由于valueCtx既不需要cancel，也不需要deadline，那么只需要实现Value()接口即可。</p>
<h4 id="2-5-1-Value（）接口实现"><a href="#2-5-1-Value（）接口实现" class="headerlink" title="2.5.1 Value（）接口实现"></a>2.5.1 Value（）接口实现</h4><p>由valueCtx数据结构定义可见，valueCtx.key和valueCtx.val分别代表其key和value值。 实现也很简单：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个细节需要关注一下，即当前context查找不到key时，会向父节点查找，如果查询不到则最终返回interface{}。也就是说，可以通过子context查询到父的value值。</p>
<h4 id="2-5-2-WithValue（）方法实现"><a href="#2-5-2-WithValue（）方法实现" class="headerlink" title="2.5.2 WithValue（）方法实现"></a>2.5.2 WithValue（）方法实现</h4><p>WithValue()实现也是非常的简单, 伪代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-典型使用案例"><a href="#2-5-3-典型使用案例" class="headerlink" title="2.5.3 典型使用案例"></a>2.5.3 典型使用案例</h4><p>下面示例程序展示valueCtx的用法：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandelRequest</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;HandelRequest Done.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;HandelRequest running, parameter: &quot;</span>, ctx.Value(<span class="string">&quot;parameter&quot;</span>))</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.WithValue(context.Background(), <span class="string">&quot;parameter&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> HandelRequest(ctx)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例main()中通过WithValue()方法获得一个context，需要指定一个父context、key和value。然后通将该context传递给子协程HandelRequest，子协程可以读取到context的key-value。</p>
<p> 注意： 本例中子协程无法自动结束，因为context是不支持cancle的，也就是说&lt;-ctx.Done()永远无法返回。如果需要返回，需要在创建context时指定一个可以cancel的context作为父节点，使用父节点的cancel()在适当的时机结束整个context。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Context仅仅是一个接口定义，跟据实现的不同，可以衍生出不同的context类型；</li>
<li>cancelCtx实现了Context接口，通过WithCancel()创建cancelCtx实例；</li>
<li>timerCtx实现了Context接口，通过WithDeadline()和WithTimeout()创建timerCtx实例；</li>
<li>valueCtx实现了Context接口，通过WithValue()创建valueCtx实例；</li>
<li>三种context实例可互为父节点，从而可以组合成不同的应用形式；</li>
</ul>

    </div>
    </article>
</div>

    <div class="_toc">
        <strong class="toc-title">
        Contents
        </strong>
        <div class="toc-content">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-text">1. 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Context%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">2. Context实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="toc-text">2.1 接口定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-Deadline"><span class="toc-text">2.1.1 Deadline()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-Done"><span class="toc-text">2.1.2 Done()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-Err"><span class="toc-text">2.1.3 Err()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-Value"><span class="toc-text">2.1.3 Value()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%A9%BAcontext"><span class="toc-text">2.2 空context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-cancelCtx"><span class="toc-text">2.3 cancelCtx</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-Done-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3.1 Done()接口实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-Err-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3.2 Err()接口实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-cancel-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3.3 cancel()接口实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-WithCancel-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3.4 WithCancel()方法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">2.3.5 典型使用案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-timerCtx"><span class="toc-text">2.4 timerCtx</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-Deadline-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.4.1 Deadline()接口实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-cancel-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.4.2 cancel()接口实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-WithDeadline-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.4.3 WithDeadline()方法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-WithTimeout-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.4.4 WithTimeout()方法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5-%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">2.4.5 典型使用案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-valueCtx"><span class="toc-text">2.5 valueCtx</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-Value%EF%BC%88%EF%BC%89%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.5.1 Value（）接口实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-WithValue%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.5.2 WithValue（）方法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">2.5.3 典型使用案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol>
        </div>
    </div>

</section>


    <nav class="post-nav">
        
            <div class="page-tags">
                
                    <a href="/tags/golang/">golang</a>
                
            </div>
        
    </nav>



    <nav class="paginator clearfix">
        
            <a class="prev" href="/2021/01/14/379/">
                <i class="iconfont icon-left"></i>
                <span class="prev-text">Redis缓存过期机制和内存淘汰管理机制</span>
            </a>
        
        
            <a class="next" href="/2020/07/13/377/">
                
                <span class="prev-text">golang WaitGroup实现原理</span>
                <i class="iconfont icon-right"></i>
            </a>
        
    </nav>


            </main>
            <div class="copyright">
  <div class="text">Powered By
    <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/zjx137/hexo-theme-Tsu">Tsu</a> &copy 2019
  </div>
</div>

        </div>
    <div class="back-to-top" id="back-to-top">
            <i class="iconfont icon-up"></i>
    </div>
        
    </body>
    
<script src="/js/jquery-3.3.1.min.js"></script>

    
<script src="/js/back-to-top.js"></script>

    
<script src="/js/scroll.js"></script>

    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

</html>
