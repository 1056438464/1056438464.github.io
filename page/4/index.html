<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<title>shang wj</title>


<link rel="stylesheet" href="/styles/main.css">


    <meta name="generator" content="Hexo 7.3.0"></head>
    <body>
        <div class="container">
            <header>
<div class="main">
<div class="title">
    <a href="#" class="logo">shang wj</a>
</div>
<div class="site-nav">
    <ul id="menu" class="menu">
    
        <li class="menu-item text-underline">
            <a href="/">Home</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/archives">Archives</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/about/">About</a>
        </li>
            
    </ul>
</div>
</div>
</header>
            <main class="main">
                <section class="posts clearfix">
    <div class="posts-wrapper">
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2021/04/14/380/">http和rpc的区别</a>
            </div>
            <p class="sub">Apr 14 2021</p>
            <div class="post-content">
                
                    <p><img src="/../images/http.PNG" alt="avatar"></p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2021/01/14/379/">Redis缓存过期机制和内存淘汰管理机制</a>
            </div>
            <p class="sub">Jan 14 2021</p>
            <div class="post-content">
                
                    <h3 id="1-缓存过期机制"><a href="#1-缓存过期机制" class="headerlink" title="1. 缓存过期机制"></a>1. 缓存过期机制</h3><p>Redis可以通过设置一个过期时间expire来处理缓存，其中处理方式有两种：</p>
<ul>
<li><strong>（主动）定期删除：</strong> Redis会抽查随机的key，默认1秒十次，一旦抽查的key过期了，就会给删除，配置的属性在redis.conf中，hz等于10，表示1秒抽查10次</li>
</ul>
<p><code>hz 10</code></p>
<ul>
<li><strong>（被动）惰性删除：</strong> key到期后不去主动检测，而是请求访问到这个key之后，会检查下是否过期，这样就不会太消耗CPU资源，缺点是一直占用着内存</li>
</ul>
<h3 id="2-内存淘汰管理机制"><a href="#2-内存淘汰管理机制" class="headerlink" title="2. 内存淘汰管理机制"></a>2. 内存淘汰管理机制</h3><p>因为计算机的内存是有限的，在部署Redis的同时，也可能部署其他的中间件如RabbitMQ、Kafka等等，为了给其他中间件预留内存空间，Redis服务启动可以设置一个最大内存maxmemory，到达阈值后，Redis会清理在内存里永久存在的没有过期时间的key，处理机制如下：<br><code>maxmemory ：当内存已使用率到达，则开始清理缓存</code></p>
<ul>
<li>noeviction：旧缓存永不过期，新缓存设置不了，返回错误</li>
<li>allkeys-lru：清除最少用的旧缓存，然后保存新的缓存（推荐使用）</li>
<li>allkeys-random：在所有的缓存中随机删除（不推荐）</li>
<li>volatile-lru：在那些设置了expire过期时间的缓存中，清除最少用的旧缓存，然后保存新的缓存</li>
<li>volatile-random：在那些设置了expire过期时间的缓存中，随机删除缓存</li>
<li>volatile-ttl：在那些设置了expire过期时间的缓存中，删除即将过期的</li>
</ul>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2020/07/14/378/">golang 并发控制context实现原理剖析</a>
            </div>
            <p class="sub">Jul 14 2020</p>
            <div class="post-content">
                
                    <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>Golang context是Golang应用开发常用的并发控制技术，它与WaitGroup最大的不同点是context对于派生goroutine有更强的控制力，它可以控制多级的goroutine。</p>
<p>context翻译成中文是”上下文”，即它可以控制一组呈树状结构的goroutine，每个goroutine拥有相同的上下文。</p>
<p>典型的使用场景如下图所示：</p>
<p><img src="/../images/context1.png" alt="avatar"></p>
<p>上图中由于goroutine派生出子goroutine，而子goroutine又继续派生新的goroutine，这种情况下使用WaitGroup就不太容易，因为子goroutine个数不容易确定。而使用context就可以很容易实现。</p>
<h2 id="2-Context实现原理"><a href="#2-Context实现原理" class="headerlink" title="2. Context实现原理"></a>2. Context实现原理</h2><p>context实际上只定义了接口，凡是实现该接口的类都可称为是一种context，官方包中实现了几个常用的context，分别可用于不同的场景。</p>
<h3 id="2-1-接口定义"><a href="#2-1-接口定义" class="headerlink" title="2.1 接口定义"></a>2.1 接口定义</h3><p>源码包中src&#x2F;context&#x2F;context.go:Context 定义了该接口：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基础的context接口只定义了4个方法，下面分别简要说明一下：</p>
<h4 id="2-1-1-Deadline"><a href="#2-1-1-Deadline" class="headerlink" title="2.1.1 Deadline()"></a>2.1.1 Deadline()</h4><p>该方法返回一个deadline和标识是否已设置deadline的bool值，如果没有设置deadline，则ok &#x3D;&#x3D; false，此时deadline为一个初始值的time.Time值</p>
<h4 id="2-1-2-Done"><a href="#2-1-2-Done" class="headerlink" title="2.1.2 Done()"></a>2.1.2 Done()</h4><p>该方法返回一个channel，需要在select-case语句中使用，如”case &lt;-context.Done():”。</p>
<p>当context关闭后，Done()返回一个被关闭的管道，关闭的管理仍然是可读的，据此goroutine可以收到关闭请求； 当context还未关闭时，Done()返回nil。</p>
<h4 id="2-1-3-Err"><a href="#2-1-3-Err" class="headerlink" title="2.1.3 Err()"></a>2.1.3 Err()</h4><p>该方法描述context关闭的原因。关闭原因由context实现控制，不需要用户设置。比如Deadline context，关闭原因可能是因为deadline，也可能提前被主动关闭，那么关闭原因就会不同:</p>
<p>因deadline关闭：“context deadline exceeded”；<br>因主动关闭： “context canceled”。<br>当context关闭后，Err()返回context的关闭原因； 当context还未关闭时，Err()返回nil；</p>
<h4 id="2-1-3-Value"><a href="#2-1-3-Value" class="headerlink" title="2.1.3 Value()"></a>2.1.3 Value()</h4><p>有一种context，它不是用于控制呈树状分布的goroutine，而是用于在树状分布的goroutine间传递信息。</p>
<p>Value()方法就是用于此种类型的context，该方法根据key值查询map中的value。具体使用后面示例说明。</p>
<h3 id="2-2-空context"><a href="#2-2-空context" class="headerlink" title="2.2 空context"></a>2.2 空context</h3><p>context包中定义了一个空的context， 名为emptyCtx，用于context的根节点，空的context只是简单的实现了Context，本身不包含任何值，仅用于其他context的父节点。</p>
<p>emptyCtx类型定义如下代码所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>context包中定义了一个公用的emptCtx全局变量，名为background，可以使用context.Background()获取它，实现代码如下所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>context包提供了4个方法创建不同类型的context，使用这四个方法时如果没有父context，都需要传入backgroud，即backgroud作为其父节点：</p>
<ul>
<li>WithCancel()</li>
<li>WithDeadline()</li>
<li>WithTimeout()</li>
<li>WithValue()</li>
</ul>
<p>context包中实现Context接口的struct，除了emptyCtx外，还有cancelCtx、timerCtx和valueCtx三种，正是基于这三种context实例，实现了上述4种类型的context。</p>
<p>context包中各context类型之间的关系，如下图所示：</p>
<p><img src="/../images/context2.webp" alt="avatar"></p>
<p>struct cancelCtx、valueCtx、valueCtx都继承于Context，下面分别介绍这三个struct。</p>
<h3 id="2-3-cancelCtx"><a href="#2-3-cancelCtx" class="headerlink" title="2.3 cancelCtx"></a>2.3 cancelCtx</h3><p>源码包中src&#x2F;context&#x2F;context.go:cancelCtx 定义了该类型context：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">	done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">	children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">	err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>children中记录了由此context派生的所有child，此context被cancle时会把其中的所有child都cancle掉。</p>
<p>cancelCtx与deadline和value无关，所以只需要实现Done()和Err()接口外露接口即可。</p>
<h4 id="2-3-1-Done-接口实现"><a href="#2-3-1-Done-接口实现" class="headerlink" title="2.3.1 Done()接口实现"></a>2.3.1 Done()接口实现</h4><p>按照Context定义，Done()接口只需要返回一个channel即可，对于cancelCtx来说只需要返回成员变量done即可。</p>
<p>这里直接看下源码，非常简单：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	d := c.done</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于cancelCtx没有指定初始化函数，所以cancelCtx.done可能还未分配，所以需要考虑初始化。<br>cancelCtx.done会在context被cancel时关闭，所以cancelCtx.done的值一般经历如三个阶段： nil –&gt; chan struct{} –&gt; closed chan。</p>
<h4 id="2-3-2-Err-接口实现"><a href="#2-3-2-Err-接口实现" class="headerlink" title="2.3.2 Err()接口实现"></a>2.3.2 Err()接口实现</h4><p>按照Context定义，Err()只需要返回一个error告知context被关闭的原因。对于cancelCtx来说只需要返回成员变量err即可。</p>
<p>还是直接看下源码：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	err := c.err</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cancelCtx.err默认是nil，在context被cancel时指定一个error变量： <code>var Canceled = errors.New(&quot;context canceled&quot;)</code>。</p>
<h4 id="2-3-3-cancel-接口实现"><a href="#2-3-3-cancel-接口实现" class="headerlink" title="2.3.3 cancel()接口实现"></a>2.3.3 cancel()接口实现</h4><p>cancel()内部方法是理解cancelCtx的最关键的方法，其作用是关闭自己和其后代，其后代存储在cancelCtx.children的map中，其中key值即后代对象，value值并没有意义，这里使用map只是为了方便查询而已。</p>
<p>cancel方法实现伪代码如下所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">	</span><br><span class="line">    c.err = err	                      <span class="comment">//设置一个error，说明关闭原因</span></span><br><span class="line">    <span class="built_in">close</span>(c.done)                     <span class="comment">//将channel关闭，以此通知派生的context</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;   <span class="comment">//遍历所有children，逐个调用cancel方法</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;            <span class="comment">//正常情况下，需要将自己从parent删除</span></span><br><span class="line">        removeChild(c.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，WithCancel()返回的第二个用于cancel context的方法正是此cancel()。</p>
<h4 id="2-3-4-WithCancel-方法实现"><a href="#2-3-4-WithCancel-方法实现" class="headerlink" title="2.3.4 WithCancel()方法实现"></a>2.3.4 WithCancel()方法实现</h4><p>WithCancel()方法作了三件事：</p>
<ul>
<li>初始化一个cancelCtx实例</li>
<li>将cancelCtx实例添加到其父节点的children中(如果父节点也可以被cancel的话)<br>*返回cancelCtx实例和cancel()方法</li>
</ul>
<p>其实现源码如下所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">	c := newCancelCtx(parent)</span><br><span class="line">	propagateCancel(parent, &amp;c)   <span class="comment">//将自身添加到父节点</span></span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将自身添加到父节点的过程有必要简单说明一下：</p>
<ol>
<li>如果父节点也支持cancel，也就是说其父节点肯定有children成员，那么把新context添加到children里即可；</li>
<li>如果父节点不支持cancel，就继续向上查询，直到找到一个支持cancel的节点，把新context添加到children里；</li>
<li>如果所有的父节点均不支持cancel，则启动一个协程等待父节点结束，然后再把当前context结束。</li>
</ol>
<h4 id="2-3-5-典型使用案例"><a href="#2-3-5-典型使用案例" class="headerlink" title="2.3.5 典型使用案例"></a>2.3.5 典型使用案例</h4><p>一个典型的使用cancel context的例子如下所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandelRequest</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> WriteRedis(ctx)</span><br><span class="line">    <span class="keyword">go</span> WriteDatabase(ctx)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;HandelRequest Done.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;HandelRequest running&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteRedis</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteRedis Done.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteRedis running&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteDatabase</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteDatabase Done.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteDatabase running&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">go</span> HandelRequest(ctx)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;It&#x27;s time to stop all sub goroutines!&quot;</span>)</span><br><span class="line">    cancel()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Just for test whether sub goroutines exit or not</span></span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中协程HandelRequest()用于处理某个请求，其又会创建两个协程：WriteRedis()、WriteDatabase()，main协程创建创建context，并把context在各子协程间传递，main协程在适当的时机可以cancel掉所有子协程。</p>
<p>程序输出如下所示：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HandelRequest running</span><br><span class="line">WriteDatabase running</span><br><span class="line">WriteRedis running</span><br><span class="line">HandelRequest running</span><br><span class="line">WriteDatabase running</span><br><span class="line">WriteRedis running</span><br><span class="line">HandelRequest running</span><br><span class="line">WriteDatabase running</span><br><span class="line">WriteRedis running</span><br><span class="line">It&#x27;s <span class="built_in">time</span> to stop all sub goroutines!</span><br><span class="line">WriteDatabase Done.</span><br><span class="line">HandelRequest Done.</span><br><span class="line">WriteRedis Done.</span><br></pre></td></tr></table></figure>

<h3 id="2-4-timerCtx"><a href="#2-4-timerCtx" class="headerlink" title="2.4 timerCtx"></a>2.4 timerCtx</h3><p>源码包中src&#x2F;context&#x2F;context.go:timerCtx 定义了该类型context：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	cancelCtx</span><br><span class="line">	timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">	deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>timerCtx在cancelCtx基础上增加了deadline用于标示自动cancel的最终时间，而timer就是一个触发自动cancel的定时器。</p>
<p>由此，衍生出WithDeadline()和WithTimeout()。实现上这两种类型实现原理一样，只不过使用语境不一样：</p>
<p>deadline: 指定最后期限，比如context将2018.10.20 00:00:00之时自动结束<br>timeout: 指定最长存活时间，比如context将在30s后结束。<br>对于接口来说，timerCtx在cancelCtx基础上还需要实现Deadline()和cancel()方法，其中cancel()方法是重写的。</p>
<h4 id="2-4-1-Deadline-接口实现"><a href="#2-4-1-Deadline-接口实现" class="headerlink" title="2.4.1 Deadline()接口实现"></a>2.4.1 Deadline()接口实现</h4><p>Deadline()方法仅仅是返回timerCtx.deadline而矣。而timerCtx.deadline是WithDeadline()或WithTimeout()方法设置的。</p>
<h4 id="2-4-2-cancel-接口实现"><a href="#2-4-2-cancel-接口实现" class="headerlink" title="2.4.2 cancel()接口实现"></a>2.4.2 cancel()接口实现</h4><p>cancel()方法基本继承cancelCtx，只需要额外把timer关闭。</p>
<p>timerCtx被关闭后，timerCtx.cancelCtx.err将会存储关闭原因：</p>
<p>如果deadline到来之前手动关闭，则关闭原因与cancelCtx显示一致；<br>如果deadline到来时自动关闭，则原因为：<code>&quot;context deadline exceeded&quot;</code></p>
<h4 id="2-4-3-WithDeadline-方法实现"><a href="#2-4-3-WithDeadline-方法实现" class="headerlink" title="2.4.3 WithDeadline()方法实现"></a>2.4.3 WithDeadline()方法实现</h4><p>WithDeadline()方法实现步骤如下：</p>
<ul>
<li>初始化一个timerCtx实例</li>
<li>将timerCtx实例添加到其父节点的children中(如果父节点也可以被cancel的话)</li>
<li>启动定时器，定时器到期后会自动cancel本context</li>
<li>返回timerCtx实例和cancel()方法</li>
</ul>
<p>也就是说，timerCtx类型的context不仅支持手动cancel，也会在定时器到来后自动cancel。</p>
<h4 id="2-4-4-WithTimeout-方法实现"><a href="#2-4-4-WithTimeout-方法实现" class="headerlink" title="2.4.4 WithTimeout()方法实现"></a>2.4.4 WithTimeout()方法实现</h4><p>WithTimeout()实际调用了WithDeadline，二者实现原理一致。</p>
<p>看代码会非常清晰：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">	<span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-5-典型使用案例"><a href="#2-4-5-典型使用案例" class="headerlink" title="2.4.5 典型使用案例"></a>2.4.5 典型使用案例</h4><p>下面例子中使用WithTimeout()获得一个context并在其了协程中传递：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandelRequest</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> WriteRedis(ctx)</span><br><span class="line">    <span class="keyword">go</span> WriteDatabase(ctx)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;HandelRequest Done.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;HandelRequest running&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteRedis</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteRedis Done.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteRedis running&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteDatabase</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteDatabase Done.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;WriteDatabase running&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, _ := context.WithTimeout(context.Background(), <span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="keyword">go</span> HandelRequest(ctx)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主协程中创建一个10s超时的context，并将其传递给子协程，10s自动关闭context。程序输出如下：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HandelRequest running</span><br><span class="line">WriteRedis running</span><br><span class="line">WriteDatabase running</span><br><span class="line">HandelRequest running</span><br><span class="line">WriteRedis running</span><br><span class="line">WriteDatabase running</span><br><span class="line">HandelRequest running</span><br><span class="line">WriteRedis running</span><br><span class="line">WriteDatabase running</span><br><span class="line">HandelRequest Done.</span><br><span class="line">WriteDatabase Done.</span><br><span class="line">WriteRedis Done.</span><br></pre></td></tr></table></figure>

<h3 id="2-5-valueCtx"><a href="#2-5-valueCtx" class="headerlink" title="2.5 valueCtx"></a>2.5 valueCtx</h3><p>源码包中src&#x2F;context&#x2F;context.go:valueCtx 定义了该类型context：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>valueCtx只是在Context基础上增加了一个key-value对，用于在各级协程间传递一些数据。</p>
<p>由于valueCtx既不需要cancel，也不需要deadline，那么只需要实现Value()接口即可。</p>
<h4 id="2-5-1-Value（）接口实现"><a href="#2-5-1-Value（）接口实现" class="headerlink" title="2.5.1 Value（）接口实现"></a>2.5.1 Value（）接口实现</h4><p>由valueCtx数据结构定义可见，valueCtx.key和valueCtx.val分别代表其key和value值。 实现也很简单：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个细节需要关注一下，即当前context查找不到key时，会向父节点查找，如果查询不到则最终返回interface{}。也就是说，可以通过子context查询到父的value值。</p>
<h4 id="2-5-2-WithValue（）方法实现"><a href="#2-5-2-WithValue（）方法实现" class="headerlink" title="2.5.2 WithValue（）方法实现"></a>2.5.2 WithValue（）方法实现</h4><p>WithValue()实现也是非常的简单, 伪代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-典型使用案例"><a href="#2-5-3-典型使用案例" class="headerlink" title="2.5.3 典型使用案例"></a>2.5.3 典型使用案例</h4><p>下面示例程序展示valueCtx的用法：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandelRequest</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;HandelRequest Done.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;HandelRequest running, parameter: &quot;</span>, ctx.Value(<span class="string">&quot;parameter&quot;</span>))</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.WithValue(context.Background(), <span class="string">&quot;parameter&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> HandelRequest(ctx)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例main()中通过WithValue()方法获得一个context，需要指定一个父context、key和value。然后通将该context传递给子协程HandelRequest，子协程可以读取到context的key-value。</p>
<p> 注意： 本例中子协程无法自动结束，因为context是不支持cancle的，也就是说&lt;-ctx.Done()永远无法返回。如果需要返回，需要在创建context时指定一个可以cancel的context作为父节点，使用父节点的cancel()在适当的时机结束整个context。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Context仅仅是一个接口定义，跟据实现的不同，可以衍生出不同的context类型；</li>
<li>cancelCtx实现了Context接口，通过WithCancel()创建cancelCtx实例；</li>
<li>timerCtx实现了Context接口，通过WithDeadline()和WithTimeout()创建timerCtx实例；</li>
<li>valueCtx实现了Context接口，通过WithValue()创建valueCtx实例；</li>
<li>三种context实例可互为父节点，从而可以组合成不同的应用形式；</li>
</ul>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2020/07/13/377/">golang WaitGroup实现原理</a>
            </div>
            <p class="sub">Jul 13 2020</p>
            <div class="post-content">
                
                    <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>WaitGroup是Golang应用开发过程中经常使用的并发控制技术。</p>
<p>WaitGroup，可理解为Wait-Goroutine-Group，即等待一组goroutine结束。比如某个goroutine需要等待其他几个goroutine全部完成，那么使用WaitGroup可以轻松实现。</p>
<p>下面程序展示了一个goroutine等待另外两个goroutine结束的例子：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">2</span>) <span class="comment">//设置计数器，数值即为goroutine的个数</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//Do some work</span></span><br><span class="line">        time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">&quot;Goroutine 1 finished!&quot;</span>)</span><br><span class="line">        wg.Done() <span class="comment">//goroutine执行结束后将计数器减1</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//Do some work</span></span><br><span class="line">        time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">&quot;Goroutine 2 finished!&quot;</span>)</span><br><span class="line">        wg.Done() <span class="comment">//goroutine执行结束后将计数器减1</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    wg.Wait() <span class="comment">//主goroutine阻塞等待计数器变为0</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;All Goroutine finished!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的说，上面程序中wg内部维护了一个计数器：</p>
<ol>
<li>启动goroutine前将计数器通过Add(2)将计数器设置为待启动的goroutine个数。</li>
<li>启动goroutine后，使用Wait()方法阻塞自己，等待计数器变为0。</li>
<li>每个goroutine执行结束通过Done()方法将计数器减1。</li>
<li>计数器变为0后，阻塞的goroutine被唤醒。</li>
</ol>
<p>其实WaitGroup也可以实现一组goroutine等待另一组goroutine，这有点像玩杂技，很容出错，如果不了解其实现原理更是如此。实际上，WaitGroup的实现源码非常简单。</p>
<h2 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2 基础知识"></a>2 基础知识</h2><h3 id="2-1-信号量"><a href="#2-1-信号量" class="headerlink" title="2.1 信号量"></a>2.1 信号量</h3><p>信号量是Unix系统提供的一种保护共享资源的机制，用于防止多个线程同时访问某个资源。</p>
<p>可简单理解为信号量为一个数值：</p>
<ul>
<li>当信号量&gt;0时，表示资源可用，获取信号量时系统自动将信号量减1；</li>
<li>当信号量&#x3D;&#x3D;0时，表示资源暂不可用，获取信号量时，当前线程会进入睡眠，当信号量为正时被唤醒；</li>
</ul>
<p>由于WaitGroup实现中也使用了信号量，在此做个简单介绍。</p>
<h2 id="3-WaitGroup"><a href="#3-WaitGroup" class="headerlink" title="3 WaitGroup"></a>3 WaitGroup</h2><h3 id="3-1-数据结构"><a href="#3-1-数据结构" class="headerlink" title="3.1 数据结构"></a>3.1 数据结构</h3><p>源码包中src&#x2F;sync&#x2F;waitgroup.go:WaitGroup定义了其数据结构：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	state1 [<span class="number">3</span>]<span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>state1是个长度为3的数组，其中包含了state和一个信号量，而state实际上是两个计数器：</p>
<ul>
<li>counter： 当前还未执行结束的goroutine计数器</li>
<li>waiter count: 等待goroutine-group结束的goroutine数量，即有多少个等候者</li>
<li>semaphore: 信号量</li>
</ul>
<p>考虑到字节是否对齐，三者出现的位置不同，为简单起见，依照字节已对齐情况下，三者在内存中的位置如下所示：</p>
<p><img src="/../images/waitgroup.webp" alt="avatar"></p>
<p>WaitGroup对外提供三个接口：</p>
<ul>
<li>Add(delta int): 将delta值加到counter中</li>
<li>Wait()： waiter递增1，并阻塞等待信号量semaphore</li>
<li>Done()： counter递减1，按照waiter数值释放相应次数信号量</li>
</ul>
<p>下面分别介绍这三个函数的实现细节。</p>
<h3 id="3-2-Add-delta-int"><a href="#3-2-Add-delta-int" class="headerlink" title="3.2 Add(delta int)"></a>3.2 Add(delta int)</h3><p>Add()做了两件事，一是把delta值累加到counter中，因为delta可以为负值，也就是说counter有可能变成0或负值，所以第二件事就是当counter值变为0时，跟据waiter数值释放等量的信号量，把等待的goroutine全部唤醒，如果counter变为负值，则panic.</p>
<p>Add()伪代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>) &#123;</span><br><span class="line">    statep, semap := wg.state() <span class="comment">//获取state和semaphore地址指针</span></span><br><span class="line">    </span><br><span class="line">    state := atomic.AddUint64(statep, <span class="type">uint64</span>(delta)&lt;&lt;<span class="number">32</span>) <span class="comment">//把delta左移32位累加到state，即累加到counter中</span></span><br><span class="line">    v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>) <span class="comment">//获取counter值</span></span><br><span class="line">    w := <span class="type">uint32</span>(state)      <span class="comment">//获取waiter值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;              <span class="comment">//经过累加后counter值变为负值，panic</span></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//经过累加后，此时，counter &gt;= 0</span></span><br><span class="line">    <span class="comment">//如果counter为正，说明不需要释放信号量，直接退出</span></span><br><span class="line">    <span class="comment">//如果waiter为零，说明没有等待者，也不需要释放信号量，直接退出</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时，counter一定等于0，而waiter一定大于0（内部维护waiter，不会出现小于0的情况），</span></span><br><span class="line">    <span class="comment">//先把counter置为0，再释放waiter个数的信号量</span></span><br><span class="line">    *statep = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">        runtime_Semrelease(semap, <span class="literal">false</span>) <span class="comment">//释放信号量，执行一次释放一个，唤醒一个等待者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-Wait"><a href="#3-3-Wait" class="headerlink" title="3.3 Wait()"></a>3.3 Wait()</h3><p>Wait()方法也做了两件事，一是累加waiter, 二是阻塞等待信号量</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait() &#123;</span><br><span class="line">    statep, semap := wg.state() <span class="comment">//获取state和semaphore地址指针</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := atomic.LoadUint64(statep) <span class="comment">//获取state值</span></span><br><span class="line">        v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)            <span class="comment">//获取counter值</span></span><br><span class="line">        w := <span class="type">uint32</span>(state)                 <span class="comment">//获取waiter值</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;                        <span class="comment">//如果counter值为0，说明所有goroutine都退出了，不需要待待，直接返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用CAS（比较交换算法）累加waiter，累加可能会失败，失败后通过for loop下次重试</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">            runtime_Semacquire(semap) <span class="comment">//累加成功后，等待信号量唤醒自己</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了CAS算法保证有多个goroutine同时执行Wait()时也能正确累加waiter。</p>
<h3 id="3-4-Done"><a href="#3-4-Done" class="headerlink" title="3.4 Done()"></a>3.4 Done()</h3><p>Done()只做一件事，即把counter减1，我们知道Add()可以接受负值，所以Done实际上只是调用了Add(-1)。</p>
<p>源码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done() &#123;</span><br><span class="line">	wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Done()的执行逻辑就转到了Add()，实际上也正是最后一个完成的goroutine把等待者唤醒的。</p>
<h2 id="4-编程Tips"><a href="#4-编程Tips" class="headerlink" title="4 编程Tips"></a>4 编程Tips</h2><p>Add()操作必须早于Wait(), 否则会panic<br>Add()设置的值必须与实际等待的goroutine个数一致，否则会panic</p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2020/07/10/376/">golang 使用channel控制并发</a>
            </div>
            <p class="sub">Jul 10 2020</p>
            <div class="post-content">
                
                    <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>channel一般用于协程之间的通信，channel也可以用于并发控制。比如主协程启动N个子协程，主协程等待所有子协程退出后再继续后续流程，这种场景下channel也可轻易实现。</p>
<h2 id="2-场景示例"><a href="#2-场景示例" class="headerlink" title="2. 场景示例"></a>2. 场景示例</h2><p>下面程序展示一个使用channel控制子协程的例子：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Process</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//Do some work...</span></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="number">1</span> <span class="comment">//管道中写入一个元素表示当前协程已结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channels := <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>) <span class="comment">//创建一个10个元素的切片，元素类型为channel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        channels[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">//切片中放入一个channel</span></span><br><span class="line">        <span class="keyword">go</span> Process(channels[i])      <span class="comment">//启动协程，传一个管道用于通信</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, ch := <span class="keyword">range</span> channels &#123;  <span class="comment">//遍历切片，等待子协程结束</span></span><br><span class="line">        &lt;-ch</span><br><span class="line">        fmt.Println(<span class="string">&quot;Routine &quot;</span>, i, <span class="string">&quot; quit!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序通过创建N个channel来管理N个协程，每个协程都有一个channel用于跟父协程通信，父协程创建完所有协程中等待所有协程结束。</p>
<p>这个例子中，父协程仅仅是等待子协程结束，其实父协程也可以向管道中写入数据通知子协程结束，这时子协程需要定期的探测管道中是否有消息出现。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>使用channel来控制子协程的优点是实现简单，缺点是当需要大量创建协程时就需要有相同数量的channel，而且对于子协程继续派生出来的协程不方便控制。</p>
<p>后面继续介绍的WaitGroup、Context看起来比channel优雅一些，在各种开源组件中使用频率比channel高得多。</p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2020/07/06/375/">golang channel 实现原理解析</a>
            </div>
            <p class="sub">Jul 06 2020</p>
            <div class="post-content">
                
                    <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>channel是Golang在语言层面提供的goroutine间的通信方式，比Unix管道更易用也更轻便。channel主要用于进程内各goroutine间通信，如果需要跨进程通信，建议使用分布式系统的方法来解决。</p>
<h2 id="2-chan数据结构"><a href="#2-chan数据结构" class="headerlink" title="2. chan数据结构"></a>2. chan数据结构</h2><p>src&#x2F;runtime&#x2F;chan.go:hchan定义了channel的数据结构：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="type">uint</span>           <span class="comment">// 当前队列中剩余元素个数</span></span><br><span class="line">	dataqsiz <span class="type">uint</span>           <span class="comment">// 环形队列长度，即可以存放的元素个数</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// 环形队列指针</span></span><br><span class="line">	elemsize <span class="type">uint16</span>         <span class="comment">// 每个元素的大小</span></span><br><span class="line">	closed   <span class="type">uint32</span>	        <span class="comment">// 标识关闭状态</span></span><br><span class="line">	elemtype *_type         <span class="comment">// 元素类型</span></span><br><span class="line">	sendx    <span class="type">uint</span>           <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">	recvx    <span class="type">uint</span>           <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">	recvq    waitq          <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">	sendq    waitq          <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line">	lock mutex              <span class="comment">// 互斥锁，chan不允许并发读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从数据结构可以看出channel由队列、类型信息、goroutine等待队列组成，下面分别说明其原理。</p>
<h3 id="2-1-环形队列"><a href="#2-1-环形队列" class="headerlink" title="2.1 环形队列"></a>2.1 环形队列</h3><p>chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的。</p>
<p>下图展示了一个可缓存6个元素的channel示意图：</p>
<p><img src="/../images/gochannel1.png" alt="avatar"></p>
<ul>
<li>dataqsiz指示了队列长度为6，即可缓存6个元素；</li>
<li>buf指向队列的内存，队列中还剩余两个元素；</li>
<li>qcount表示队列中还有两个元素；</li>
<li>sendx指示后续写入的数据存储的位置，取值[0, 6)；</li>
<li>recvx指示从该位置读取数据, 取值[0, 6)；</li>
</ul>
<h3 id="2-2-等待队列"><a href="#2-2-等待队列" class="headerlink" title="2.2 等待队列"></a>2.2 等待队列</h3><p>从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。<br>向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。</p>
<p>被阻塞的goroutine将会挂在channel的等待队列中：</p>
<ul>
<li>因读阻塞的goroutine会被向channel写入数据的goroutine唤醒；</li>
<li>因写阻塞的goroutine会被从channel读数据的goroutine唤醒；</li>
</ul>
<p>下图展示了一个没有缓冲区的channel，有几个goroutine阻塞等待读数据：</p>
<p><img src="/../images/channel2.png" alt="avatar"></p>
<p>注意，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。</p>
<h3 id="2-3-类型信息"><a href="#2-3-类型信息" class="headerlink" title="2.3 类型信息"></a>2.3 类型信息</h3><p>一个channel只能传递一种类型的值，类型信息存储在hchan数据结构中。</p>
<ul>
<li>elemtype代表类型，用于数据传递过程中的赋值；</li>
<li>elemsize代表类型大小，用于在buf中定位元素位置。</li>
</ul>
<h3 id="2-4-锁"><a href="#2-4-锁" class="headerlink" title="2.4 锁"></a>2.4 锁</h3><p>一个channel同时仅允许被一个goroutine读写，为简单起见，本章后续部分说明读写过程时不再涉及加锁和解锁。</p>
<h2 id="3-channel读写"><a href="#3-channel读写" class="headerlink" title="3. channel读写"></a>3. channel读写</h2><h3 id="3-1-创建channel"><a href="#3-1-创建channel" class="headerlink" title="3.1 创建channel"></a>3.1 创建channel</h3><p>创建channel的过程实际上是初始化hchan结构。其中类型信息和缓冲区长度由make语句传入，buf的大小则与元素大小和缓冲区长度共同决定。</p>
<p>创建channel的伪代码如下所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	c = <span class="built_in">new</span>(hchan)</span><br><span class="line">	c.buf = malloc(元素类型大小*size)</span><br><span class="line">	c.elemsize = 元素类型大小</span><br><span class="line">	c.elemtype = 元素类型</span><br><span class="line">	c.dataqsiz = size</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-向channel写数据"><a href="#3-2-向channel写数据" class="headerlink" title="3.2 向channel写数据"></a>3.2 向channel写数据</h3><p>向一个channel中写数据简单过程如下：</p>
<p>如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程；<br>如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程；<br>如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒；<br>简单流程图如下：</p>
<p><img src="/../images/channel3.png" alt="avatar"></p>
<h3 id="3-3-从channel读数据"><a href="#3-3-从channel读数据" class="headerlink" title="3.3 从channel读数据"></a>3.3 从channel读数据</h3><p>从一个channel读数据简单过程如下：</p>
<ol>
<li>如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；</li>
<li>如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；</li>
<li>如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；<br>将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；</li>
</ol>
<p>简单流程图如下：</p>
<p><img src="/../images/channel4.webp" alt="avatar"></p>
<h3 id="3-4-关闭channel"><a href="#3-4-关闭channel" class="headerlink" title="3.4 关闭channel"></a>3.4 关闭channel</h3><p>关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。</p>
<p>除此之外，panic出现的常见场景还有：</p>
<p>关闭值为nil的channel<br>关闭已经被关闭的channel<br>向已经关闭的channel写数据</p>
<h2 id="4-常见用法"><a href="#4-常见用法" class="headerlink" title="4. 常见用法"></a>4. 常见用法</h2><h3 id="4-1-单向channel"><a href="#4-1-单向channel" class="headerlink" title="4.1 单向channel"></a>4.1 单向channel</h3><p>顾名思义，单向channel指只能用于发送或接收数据，实际上并没有单向channel。</p>
<p>我们知道channel可以通过参数传递，所谓单向channel只是对channel的一种使用限制，这跟C语言使用const修饰函数参数为只读是一个道理。</p>
<p>func readChan(chanName &lt;-chan int)： 通过形参限定函数内部只能从channel中读取数据<br>func writeChan(chanName chan&lt;- int)： 通过形参限定函数内部只能向channel中写入数据<br>一个简单的示例程序如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readChan</span><span class="params">(chanName &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    &lt;- chanName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeChan</span><span class="params">(chanName <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    chanName &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mychan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    writeChan(mychan)</span><br><span class="line">    readChan(mychan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mychan是个正常的channel，而readChan()参数限制了传入的channel只能用来读，writeChan()参数限制了传入的channel只能用来写。</p>
<h3 id="4-2-select"><a href="#4-2-select" class="headerlink" title="4.2 select"></a>4.2 select</h3><p>使用select可以监控多channel，比如监控多个channel，当其中某一个channel有数据时，就从其读出数据。</p>
<p>一个简单的示例程序如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNumberToChan</span><span class="params">(chanName <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        chanName &lt;- <span class="number">1</span></span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> chan1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">var</span> chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> addNumberToChan(chan1)</span><br><span class="line">    <span class="keyword">go</span> addNumberToChan(chan2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e := &lt;- chan1 :</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Get element from chan1: %d\n&quot;</span>, e)</span><br><span class="line">        <span class="keyword">case</span> e := &lt;- chan2 :</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Get element from chan2: %d\n&quot;</span>, e)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;No element in chan1 and chan2.\n&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序中创建两个channel： chan1和chan2。函数addNumberToChan()函数会向两个channel中周期性写入数据。通过select可以监控两个channel，任意一个可读时就从其中读出数据。</p>
<p>程序输出如下：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">SourceCode</span>\<span class="title">GoExpert</span>\<span class="title">src</span>&gt;<span class="title">go</span> <span class="title">run</span> <span class="title">main.go</span></span></span><br><span class="line"><span class="function"><span class="title">Get</span> <span class="title">element</span> <span class="title">from</span> <span class="title">chan1</span>: 1</span></span><br><span class="line"><span class="function"><span class="title">Get</span> <span class="title">element</span> <span class="title">from</span> <span class="title">chan2</span>: 1</span></span><br><span class="line"><span class="function"><span class="title">No</span> <span class="title">element</span> <span class="title">in</span> <span class="title">chan1</span> <span class="title">and</span> <span class="title">chan2</span>.</span></span><br><span class="line"><span class="function"><span class="title">Get</span> <span class="title">element</span> <span class="title">from</span> <span class="title">chan2</span>: 1</span></span><br><span class="line"><span class="function"><span class="title">Get</span> <span class="title">element</span> <span class="title">from</span> <span class="title">chan1</span>: 1</span></span><br><span class="line"><span class="function"><span class="title">No</span> <span class="title">element</span> <span class="title">in</span> <span class="title">chan1</span> <span class="title">and</span> <span class="title">chan2</span>.</span></span><br><span class="line"><span class="function"><span class="title">Get</span> <span class="title">element</span> <span class="title">from</span> <span class="title">chan2</span>: 1</span></span><br><span class="line"><span class="function"><span class="title">Get</span> <span class="title">element</span> <span class="title">from</span> <span class="title">chan1</span>: 1</span></span><br><span class="line"><span class="function"><span class="title">No</span> <span class="title">element</span> <span class="title">in</span> <span class="title">chan1</span> <span class="title">and</span> <span class="title">chan2</span>.</span></span><br></pre></td></tr></table></figure>

<p>从输出可见，从channel中读出数据的顺序是随机的，事实上select语句的多个case执行顺序是随机的，关于select的实现原理会有专门章节分析。</p>
<p>通过这个示例想说的是：select的case语句读channel不会阻塞，尽管channel中没有数据。这是由于case语句编译后调用读channel时会明确传入不阻塞的参数，此时读不到数据时不会将当前goroutine加入到等待队列，而是直接返回。</p>
<h3 id="4-3-range"><a href="#4-3-range" class="headerlink" title="4.3 range"></a>4.3 range</h3><p>通过range可以持续从channel中读出数据，好像在遍历一个数组一样，当channel中没有数据时会阻塞当前goroutine，与读channel时阻塞处理机制一样。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanRange</span><span class="params">(chanName <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> e := <span class="keyword">range</span> chanName &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Get element from chan: %d\n&quot;</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果向此channel写数据的goroutine退出时，系统检测到这种情况后会panic，否则range将会永久阻塞</p>
<p><em>其他拓展</em></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27917262">https://zhuanlan.zhihu.com/p/27917262</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27917262">https://zhuanlan.zhihu.com/p/27917262</a></p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2020/05/06/374/">java线程池使用例子</a>
            </div>
            <p class="sub">May 06 2020</p>
            <div class="post-content">
                
                    <h3 id="1-invokeAll"><a href="#1-invokeAll" class="headerlink" title="1.invokeAll"></a>1.invokeAll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newFixedThreadPool(threadNum);</span><br><span class="line"></span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Callable&lt;Integer&gt;&gt;();</span><br><span class="line">    Callable&lt;Integer&gt; task = <span class="literal">null</span>;</span><br><span class="line">    List&lt;List&gt; cutList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定每条线程的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == threadNum - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (special) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cutList = jsonList.subList(threadSize * i, dataSize);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cutList = jsonList.subList(threadSize * i, threadSize * (i + <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">final</span> List&lt;List&gt; listStr = cutList;</span><br><span class="line">      task =</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">              ··· 代码 ···</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">      <span class="comment">// 这里提交的任务容器列表和返回的Future列表存在顺序对应的关系</span></span><br><span class="line">      tasks.add(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exec.invokeAll(tasks);</span><br><span class="line">    exec.shutdown();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-submit"><a href="#2-submit" class="headerlink" title="2.submit"></a>2.submit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newFixedThreadPool(threadNum);</span><br><span class="line"></span><br><span class="line">   List&lt;Runnable&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   List&lt;List&gt; cutList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 确定每条线程的数据</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (i == threadNum - <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (special) &#123;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       cutList = jsonList.subList(threadSize * i, dataSize);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       cutList = jsonList.subList(threadSize * i, threadSize * (i + <span class="number">1</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">final</span> List&lt;List&gt; listStr = cutList;</span><br><span class="line">     task =</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               ··· 代码 ···</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">     <span class="comment">// 这里提交的任务容器列表和返回的Future列表存在顺序对应的关系</span></span><br><span class="line">     exec.submit(task);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   exec.shutdown();</span><br><span class="line">   <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (exec.isTerminated()) &#123;</span><br><span class="line">       <span class="keyword">return</span> resInfo;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-execute"><a href="#3-execute" class="headerlink" title="3.execute"></a>3.execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);        </span><br><span class="line">es.execute(<span class="keyword">new</span> <span class="title class_">Thread</span>());<span class="comment">//执行子线程任务     </span></span><br><span class="line">   <span class="keyword">try</span> &#123;    </span><br><span class="line">    es.shutdown();  </span><br><span class="line">        <span class="keyword">if</span>(!es.awaitTermination(<span class="number">20</span>,TimeUnit.SECONDS))&#123;<span class="comment">//20S </span></span><br><span class="line">       System.out.println(<span class="string">&quot; 到达指定时间，还有线程没执行完，不再等待，关闭线程池!&quot;</span>);      </span><br><span class="line">       es.shutdownNow();    </span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;     <span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line">    es.shutdownNow();   </span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2020/04/15/372/">MySql 锁</a>
            </div>
            <p class="sub">Apr 15 2020</p>
            <div class="post-content">
                
                    <h2 id="1-锁机制"><a href="#1-锁机制" class="headerlink" title="1.锁机制"></a>1.锁机制</h2><h3 id="共享锁与排他锁"><a href="#共享锁与排他锁" class="headerlink" title="共享锁与排他锁"></a>共享锁与排他锁</h3><ul>
<li>共享锁（读锁）：其他事务可以读，但不能写。</li>
<li>排他锁（写锁） ：其他事务不能读取，也不能写。</li>
</ul>
<p><strong>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞</strong></p>
<h3 id="1-1-粒度锁"><a href="#1-1-粒度锁" class="headerlink" title="1.1 粒度锁"></a>1.1 粒度锁</h3><p>MySQL 不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式显现了锁机制，服务器层完全不了解存储引擎中的锁实现：</p>
<p><code>MyISAM</code> 和 <code>MEMORY</code> 存储引擎采用的是<strong>表级锁</strong>（table-level locking）<br>BDB 存储引擎采用的是页面锁（page-level locking），但也支持表级锁。<br><code>InnoDB</code> 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用<strong>行级锁</strong>。<br><em>默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。</em></p>
<p>但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p>
<h4 id="不同粒度锁的比较："><a href="#不同粒度锁的比较：" class="headerlink" title="不同粒度锁的比较："></a>不同粒度锁的比较：</h4><ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。<br>表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用。</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>最大程度的支持并发，同时也带来了最大的锁开销。<br>在 InnoDB 中，除单个 SQL 组成的事务外，<br>锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。<br>行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
<h3 id="2-MyISAM-表锁"><a href="#2-MyISAM-表锁" class="headerlink" title="2.MyISAM 表锁"></a>2.MyISAM 表锁</h3><h4 id="2-1-MyISAM表级锁模式："><a href="#2-1-MyISAM表级锁模式：" class="headerlink" title="2.1 MyISAM表级锁模式："></a>2.1 MyISAM表级锁模式：</h4><ul>
<li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li>
<li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；<br>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。 其他线程的读、 写操作都会等待，直到锁被释放为止。</li>
</ul>
<p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</p>
<p>这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。同时，一些需要长时间运行的查询操作，也会使写线程“饿死” ，应用中应尽量避免出现长时间运行的查询操作（在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解” ，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行）。</p>
<h4 id="2-2-MyISAM加表锁方法："><a href="#2-2-MyISAM加表锁方法：" class="headerlink" title="2.2 MyISAM加表锁方法："></a>2.2 MyISAM加表锁方法：</h4><p>MyISAM 在执行查询语句（SELECT）前，会<code>自动</code>给涉及的表加<code>读锁</code>，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会<code>自动</code>给涉及的表加<code>写锁</code>，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。</p>
<p>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的<code>全部锁</code>，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加锁：lock table table_nmae read|write;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解锁锁：unlock tables;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-查询表级锁争用情况："><a href="#2-3-查询表级锁争用情况：" class="headerlink" title="2.3 查询表级锁争用情况："></a>2.3 查询表级锁争用情况：</h4><p>可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁的争夺，如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE &#x27;Table%&#x27;;</span><br><span class="line">+-----------------------+---------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-----------------------+---------+</span><br><span class="line">| Table_locks_immediate | 2       |</span><br><span class="line">| Table_locks_waited    | 1       |</span><br><span class="line">+-----------------------+---------+</span><br></pre></td></tr></table></figure>
<h3 id="3-InnoDB行级锁和表级锁"><a href="#3-InnoDB行级锁和表级锁" class="headerlink" title="3.InnoDB行级锁和表级锁"></a>3.InnoDB行级锁和表级锁</h3><h4 id="InnoDB锁模式："><a href="#InnoDB锁模式：" class="headerlink" title="InnoDB锁模式："></a>InnoDB锁模式：</h4><p>InnoDB 实现了以下两种类型的行锁：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li>
</ul>
<p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁：</p>
<ul>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li>
</ul>
<h4 id="3-1-InnoDB加锁方法："><a href="#3-1-InnoDB加锁方法：" class="headerlink" title="3.1 InnoDB加锁方法："></a>3.1 InnoDB加锁方法：</h4><ul>
<li>意向锁:是 InnoDB <code>自动</code>加的， <em>不需用户干预</em>。</li>
<li>对于 ‘UPDATE、 DELETE 和 INSERT ‘语句， InnoDB会自动给涉及数据集加排他锁（X)；<br>对于普通 SELECT 语句，InnoDB 不会加任何锁；<br>事务可以通过以下语句显式给记录集加共享锁或排他锁：</li>
<li>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</li>
</ul>
<h5 id="隐式锁定："><a href="#隐式锁定：" class="headerlink" title="隐式锁定："></a>隐式锁定：</h5><p>InnoDB在事务执行过程中，使用两阶段锁协议：</p>
<p>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</p>
<p>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。</p>
<h5 id="显式锁定-："><a href="#显式锁定-：" class="headerlink" title="显式锁定 ："></a>显式锁定 ：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select ... lock in share mode //共享锁 </span><br><span class="line">select ... for update //排他锁 </span><br></pre></td></tr></table></figure>
<h6 id="for-update-和-lock-in-share-mode-的区别："><a href="#for-update-和-lock-in-share-mode-的区别：" class="headerlink" title="for update 和 lock in share mode 的区别："></a>for update 和 lock in share mode 的区别：</h6><ul>
<li><p>共享锁又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</p>
</li>
<li><p>排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</p>
</li>
</ul>
<p><code>for update</code> 是排他锁（X 锁），一旦一个事务获取了这个锁，其他的事务是没法在这些数据上执行 for update ；<code>lock in share mode</code>是共享锁，多个事务可以同时的对相同数据执行 lock in share mode。</p>
<h4 id="3-2-InnoDB的间隙锁："><a href="#3-2-InnoDB的间隙锁：" class="headerlink" title="3.2 InnoDB的间隙锁："></a>3.2 InnoDB的间隙锁：</h4><p>当我们用<code>范围条件</code>而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p>
<p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>
<h5 id="InnoDB使用间隙锁的目的："><a href="#InnoDB使用间隙锁的目的：" class="headerlink" title="InnoDB使用间隙锁的目的："></a>InnoDB使用间隙锁的目的：</h5><ul>
<li>防止幻读，以满足相关隔离级别的要求；</li>
<li>满足恢复和复制的需要：</li>
</ul>
<h4 id="3-3-获取-InnoDB-行锁争用情况："><a href="#3-3-获取-InnoDB-行锁争用情况：" class="headerlink" title="3.3 获取 InnoDB 行锁争用情况："></a>3.3 获取 InnoDB 行锁争用情况：</h4><p>可以通过检查 InnoDB_row_lock 状态变量来分析系统上的行锁的争夺情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &#x27;innodb_row_lock%&#x27;; </span><br><span class="line">+-------------------------------+-------+ </span><br><span class="line">| Variable_name                 | Value | </span><br><span class="line">+-------------------------------+-------+ </span><br><span class="line">| InnoDB_row_lock_current_waits | 0     | </span><br><span class="line">| InnoDB_row_lock_time          | 0     | </span><br><span class="line">| InnoDB_row_lock_time_avg      | 0     | </span><br><span class="line">| InnoDB_row_lock_time_max      | 0     | </span><br><span class="line">| InnoDB_row_lock_waits         | 0     | </span><br><span class="line">+-------------------------------+-------+ </span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2020/04/14/373/">MySql 事务</a>
            </div>
            <p class="sub">Apr 14 2020</p>
            <div class="post-content">
                
                    <h3 id="1-事务（Transaction）及其ACID属性"><a href="#1-事务（Transaction）及其ACID属性" class="headerlink" title="1.事务（Transaction）及其ACID属性"></a>1.事务（Transaction）及其ACID属性</h3><p><strong>事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。</strong></p>
<ul>
<li><strong>原性性（Actomicity）</strong>：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li>
<li><strong>一致性（Consistent）</strong>：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数* 据结构（如B树索引或双向链表）也都必须是正确的。</li>
<li><strong>隔离性（Isolation）</strong>：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li>
<li><strong>持久性（Durable）</strong>：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li>
</ul>
<h3 id="2-并发事务带来的问题"><a href="#2-并发事务带来的问题" class="headerlink" title="2.并发事务带来的问题"></a>2.并发事务带来的问题</h3><p>相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。</p>
<ul>
<li><strong>更新丢失（Lost Update）</strong>：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题</li>
<li><strong>脏读（Dirty Reads）</strong>：A事务读取B事务尚未提交的更改数据，并在这个数据的基础上进行操作，这时候如果事务B回滚，那么A事务读到的数据是不被承认的。。这种现象被形象地叫做“脏读”。</li>
<li><strong>不可重复读（Non-Repeatable Reads）</strong>：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。<br>也就是说，当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。</li>
<li><strong>幻读（Phantom Reads）</strong>：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。<br>也就是说，当前事务读第一次取到的数据比后来读取到数据条目少。</li>
</ul>
<h4 id="不可重复读和幻读比较："><a href="#不可重复读和幻读比较：" class="headerlink" title="不可重复读和幻读比较："></a>不可重复读和幻读比较：</h4><p>两者有些相似，但是前者针对的是update或delete，后者针对的insert。</p>
<p><em>注意：不可重复读和幻读的区别是：前者是指读到了已经提交的事务的更改数据（修改或删除），后者是指读到了其他已经提交事务的新增数据。</em></p>
<h3 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3.事务隔离级别"></a>3.事务隔离级别</h3><p>在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。<br>“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本可以分为以下两种。<br>一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。<br>另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。<br>数据库的事务隔离级别越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的，同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。<br>为了解决“隔离”与“并发”的矛盾，ISO&#x2F;ANSI SQL92定义了４个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己业务逻辑要求，通过选择不同的隔离级别来平衡＂隔离＂与＂并发＂的矛盾</p>
<h4 id="事务４种隔离级别比较"><a href="#事务４种隔离级别比较" class="headerlink" title="事务４种隔离级别比较"></a>事务４种隔离级别比较</h4><table>
<thead>
<tr>
<th>隔离级别&#x2F;读数据一致性及允许的并发副作用</th>
<th>读数据一致性</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读（Read uncommitted）</td>
<td>最低级别，只能保证不读取物理上损坏的数据</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>已提交读（Read committed）</td>
<td>语句级</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（Repeatable read）</td>
<td>事务级</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>可序列化（Serializable）</td>
<td>最高级别，事务级</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>总结:</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1.脏读：事务 A 读取了事务 B 未提交的数据，并在这个基础上又做了其他操作。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2.不可重复读：事务 A 读取了事务 B 已提交的更改数据。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3.幻读：事务 A 读取了事务 B 已提交的新增数据。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>最后要说明的是</strong>：各具体数据库并不一定完全实现了上述４个隔离级别，例如，Oracle只提供Read committed和Serializable两个标准级别，另外还自己定义的Read only隔离级别：SQL Server除支持上述ISO&#x2F;ANSI SQL92定义的４个级别外，还支持一个叫做＂快照＂的隔离级别，但严格来说它是一个用MVCC实现的Serializable隔离级别。ＭySQL支持全部４个隔离级别，但在具体实现时，有一些特点，比如在一些隔离级下是采用MVCC一致性读，但某些情况又不是。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2020/04/09/371/">MySql explain</a>
            </div>
            <p class="sub">Apr 09 2020</p>
            <div class="post-content">
                
                    <h2 id="1-执行计划包含字段"><a href="#1-执行计划包含字段" class="headerlink" title="1.执行计划包含字段"></a>1.执行计划包含字段</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+------+-------------+--------------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">| id   | select_type | table        | type | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+------+-------------+--------------+------+---------------+------+---------+------+------+-------+</span><br></pre></td></tr></table></figure>
<h3 id="id-表的读取顺序"><a href="#id-表的读取顺序" class="headerlink" title="id 表的读取顺序"></a>id 表的读取顺序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT识别符。这是SELECT的查询序列号</span><br><span class="line">我的理解是SQL执行的顺序的标识，SQL从大到小的执行</span><br><span class="line"></span><br><span class="line">1.id相同时，执行顺序由上至下</span><br><span class="line">2.如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</span><br><span class="line">3.id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</span><br></pre></td></tr></table></figure>
<h3 id="select-type-数据读取操作的操作类型"><a href="#select-type-数据读取操作的操作类型" class="headerlink" title="select_type 数据读取操作的操作类型"></a>select_type 数据读取操作的操作类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表示查询中每个select子句的类型</span><br><span class="line"></span><br><span class="line">1.SIMPLE(简单查询，不使用UNION或子查询等)</span><br><span class="line">2.PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</span><br><span class="line">3.UNION(UNION中的第二个或后面的SELECT语句)</span><br><span class="line">4.DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</span><br><span class="line">5.UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)</span><br><span class="line">6.SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)</span><br><span class="line">7.DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</span><br><span class="line">8.DERIVED(派生表的SELECT, FROM子句的子查询，结果放在临时表里)</span><br><span class="line">9.UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</span><br></pre></td></tr></table></figure>
<h3 id="type-访问类型排列"><a href="#type-访问类型排列" class="headerlink" title="type 访问类型排列"></a>type 访问类型排列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">从最好到最差次序</span><br><span class="line">NULL&gt;system&gt;const&gt;eq_ref&gt;ref&gt;flltext&gt;ref_or_null&gt;index_merge&gt;unique_subquery&gt;index_subquery&gt;range&gt;index&gt;ALL</span><br><span class="line">省略次序</span><br><span class="line">system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</span><br><span class="line"></span><br><span class="line">1.ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</span><br><span class="line">2.index: Full Index Scan，index与ALL区别为index类型只遍历索引树</span><br><span class="line">3.range:只检索给定范围的行，使用一个索引来选择行</span><br><span class="line">4.ref: （非唯一性索引扫描）表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</span><br><span class="line">5.eq_ref:（唯一性索引扫描） 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</span><br><span class="line">6.const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system.(主键索引)</span><br><span class="line">7.NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</span><br></pre></td></tr></table></figure>
<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</span><br></pre></td></tr></table></figure>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key列显示MySQL实际决定使用的键（索引），必然包含在possible_keys中</span><br></pre></td></tr></table></figure>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）</span><br><span class="line">不损失精确性的情况下，长度越短越好 </span><br></pre></td></tr></table></figure>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</span><br></pre></td></tr></table></figure>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数(每张表有多少行被优化器查询到)</span><br><span class="line">越少越好。</span><br></pre></td></tr></table></figure>
<h3 id="Extra-其他重要信息"><a href="#Extra-其他重要信息" class="headerlink" title="Extra 其他重要信息"></a>Extra 其他重要信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">该列包含MySQL解决查询的详细信息,有以下几种情况：</span><br><span class="line"></span><br><span class="line">1.Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by。</span><br><span class="line">最好按照你的索引个数和顺序来</span><br><span class="line">2.Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”。</span><br><span class="line">3.Using Index：表示相应的select操作中使用了覆盖索引(Covering Index)， 避免访问了表的数据行，效率不错!</span><br><span class="line">如果同时出现using where,表明索引被用来执行索引键值的查找;</span><br><span class="line">如果没有同时出现usingwhere,表明索引用来读取数据而非执行查找动作。</span><br><span class="line">4.Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，</span><br><span class="line">这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</span><br><span class="line">5.Using join buffer：改值强调了在获取连接条件时没有使用索引,并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</span><br><span class="line">6.Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。</span><br><span class="line">7.Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</span><br><span class="line">8.No tables used：Query语句中使用from dual 或不含任何from子句</span><br></pre></td></tr></table></figure>
                
            </div>
        </article>
    
</div>
<div class="side-bar">


    <div class="avator" id="avator">
    <div class="title">
        <a href="#" class="text-underline">About Me</a>
    </div>
        <img src="avator.jpg" class="ava-img">
        <h3 class="author">shang wj</h3>
        <div class="icon-list">
        <a href="yourweibo"><i class="iconfont icon-weibo icon-item"></i></a>
        <a href="mailto:youremail"><i class="iconfont icon-email icon-item"></i></a>
        <a href="yourgithub"><i class="iconfont icon-github icon-item"></i></a>
        <a href="yourlinkedin"><i class="iconfont icon-linkedin icon-item"></i></a>
        </div>
    <div class="tags">
    <h3 class="tags-title">Tags</h3>
    <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E6%83%85/" rel="tag">心情</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">知识点</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/enable/" rel="tag">enable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/systemctl/" rel="tag">systemctl</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%9C%BA/" rel="tag">开机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php-fpm/" rel="tag">php-fpm</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/" rel="tag">php</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/obj/" rel="tag">obj</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/str/" rel="tag">str</a><span class="tag-list-count">1</span></li></ul>
</div>
    </div>
</div>

</section>

    <nav class="page-nav">
    
        <a class="prev" href="/page/3/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text">Prev</span>
        </a>
    
    
        <a class="next" href="/page/5/">
            <span class="next-text">Next</span>
            <i class="iconfont icon-right"></i>
        </a>
    
    </nav>



            </main>
            <div class="copyright">
  <div class="text">Powered By
    <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/zjx137/hexo-theme-Tsu">Tsu</a> &copy 2019
  </div>
</div>

        </div>
    <div class="back-to-top" id="back-to-top">
            <i class="iconfont icon-up"></i>
    </div>
        
    </body>
    
<script src="/js/jquery-3.3.1.min.js"></script>

    
<script src="/js/back-to-top.js"></script>

    
<script src="/js/scroll.js"></script>

    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

</html>
